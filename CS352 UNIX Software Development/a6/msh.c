/*	$Id: msh.c,v 1.34 2014/12/05 08:56:05 felchs Exp $	*/
/* CS 352 -- Mini Shell!  
 *   Scotty Felch
 *   Fall 2014
 *   Assignment 6
 * 
 *   Original source:
 *   Sept 21, 2000,  Phil Nelson
 *   Modified April 8, 2001 
 *   Modified January 6, 2003
 *
 */

#include <ctype.h>		/* used for isdigit(3) */
#include <errno.h>
#include <fcntl.h>		/* used for open(2) flags */
#include <signal.h>		/* used for sig_atomic_t data type */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>	/* used for fchmod(2) */
#include <sys/types.h>	/* used for wait(2) */
#include <sys/wait.h>	/* used for wait(2) */
#include <unistd.h>

#include "globals.h"	/* shared data between files */
#include "proto.h"		/* shared function prototypes */

/* Constants */ 
#define LINELEN 200000
#define MAX_FDS 1626878

/* Accessing globals */
int    interactive_mode;
int    last_exit_value;	
int    m_argc;			/* Number of arguments passed into msh */
char **m_argv;			/* Arguments passed into msh */
__sig_atomic_t sigint_occurred = 0;

/* Local prototypes */ 
void catch_signal 	  (int sig);
int find_path 		  (char *line, int *ix, char *path, char *full_path);
int find_pipe		  (char *expline);
int processline 	  (char *line, 
				 	   int infd, 
				 	   int outfd, 
				 	   int errfd, 
				 	   int flag);
int process_redirect  (char *expline, int *cinfd, int *coutfd, int *cerrfd);
int process_pipelines (char *expline, int *cinfd, int *coutfd, int *cerrfd);

/* Debug control */
int msh_debug = 0;

/* Shell main */
int main (int terminal_argc, char **terminal_argv) {
	char buffer [LINELEN] = "";
	char prompt [LINELEN] = "";	
	interactive_mode = 1;
	FILE* input_stream = stdin;
	m_argc = terminal_argc;		/* Store # of terminal args in globals.h */
	m_argv = terminal_argv;		/* Store terminal args in globals.h */

	/* Setup signal handler struct */
	struct sigaction sa;
	sa.sa_handler = catch_signal;
	sigemptyset(&sa.sa_mask); 
	sa.sa_flags = SA_RESTART;
	sigaction(SIGINT, &sa, NULL);

	/* User prompt is gathered from env variable, defaults to "% " otherwise */
	if (getenv("P1"))
		strcat(prompt, getenv("P1"));
	else
		strcat(prompt, "%");

	/* Assign script input, if applicable. */
	if (m_argc > 1) {
		/* Open input file specified in 2nd arg, read only mode.
		 * Error in opening returns NULL and sets errno. */
		if (!(input_stream = fopen(m_argv[1], "r"))) {
			fprintf(stderr, "Invalid input script specified, aborting\n");
			exit(127);
		}
		else
			interactive_mode = 0;
	}

	while(!sigint_occurred) {
		/* prompt and get line */
		if (interactive_mode) fprintf (stderr, "%s ", prompt);
		if (fgets (buffer, LINELEN, input_stream) != buffer)
			break;

		/* Get rid of \n at end of buffer. */
		int len = strlen(buffer);
		if (buffer[len-1] == '\n')
			buffer[len-1] = 0;

		/* Detect comment sentinal char and replace with null */
		int in_quote = 0;			/* In quotes = disregard comment # */
		int ix;
		for (ix = 0; ix < len; ix++) {
			if (buffer[ix] == '\"') 
				in_quote = !in_quote;
			if (!in_quote && buffer[ix] == '#' && buffer[ix-1] != '$' ) {
				buffer[ix] = 0;
				break;
			}
		}

		/* Run it ... */
		(void) processline (buffer,	STDIN, STDOUT, STDERR, \
							WAIT_PLS | EXPAND_PLS);
		sigint_occurred = 0;
	}

	if (!feof(input_stream))
		perror ("read");

	fclose(input_stream);	/* Clean the kitchen */
	return 0;				/* Burn the house down */
}

/* Return values:			
	-1 == error
	 0 == successful completion of builtin or syscall
	>0 == pid of child on which to wait */
int processline (char *line, int infd, int outfd, int errfd, int flag) {
	char **argv; 			/* Array of strings populated by arg_parse() */
	char expline [LINELEN];	/* String to be populated with expanded variables */
	int num_args;			/* Num args in current line of input */
	int	status;				/* Holds return value of wait(3) */
	pid_t  cpid;			/* Process id generated by forking off child */


	int cinfd = infd;		/* Child input file descriptor */
	int coutfd = outfd;		/* Child output file descriptor */
	int cerrfd = errfd;		/* Child error file descriptor */


	kill_zombies();			/* Clear any zombies before/after every line. */

	// printf("PL! expline:\t\\%s\\\n", line);

	if (EXPAND_PLS & flag) {
		int expand_failed = expand(line, expline, LINELEN);
		if (expand_failed) 
			return -1;
	
		/* Get rid of \n at end of buffer. */
		int len = strlen(expline);
		if (expline[len-1] == '\n')
			expline[len-1] = 0;
	}
	else {
		/* If not exanding just copy line into expline unmodified */
		strncpy(expline, line, strlen(line));
	}

	/* Do I want to handle pipelines in-line here? Will it make a difference
	versus doing it in a helper function? */
	if (find_pipe(expline)) 
		process_pipelines(expline, &cinfd, &coutfd, &cerrfd);
	
	if (process_redirect(expline, &cinfd, &coutfd, &cerrfd)) 
		return -1;

	num_args = arg_parse(expline, &argv);
	if (num_args <= 0)
		return 0;

	/* Execute builtin if possible, otherwise fork off. */ 
	int was_builtin = exec_builtin(argv, num_args, cinfd, coutfd, cerrfd);

	if (was_builtin) {
		free(argv);
		return 0;
	}
	else {
		/* Start a new process to do the job. */
		cpid = fork();
		if (cpid < 0) {
			perror ("fork");
			return -1;
		}
		
		/* Check for who we are! */
		if (cpid == 0) {
			/* We are the child! */
			/* redirect STDOUT to point to write end of pipe 
			 * goes away when child dies */
			if (coutfd != STDOUT) {
				dup2(coutfd, 1);
				close(coutfd);
			}

			execvp(argv[0], argv);
			perror ("exec");
			exit (127);
		}
		
		free(argv);

		/* Either wait on child or return child pid */
		if ( flag & WAIT_PLS) {
			kill_zombies();
			/* Have the parent wait for child to complete */
			// if (wait(&status) < 0){
			if (waitpid(cpid, &status, 0) < 0){
				perror ("wait");
				return -1;
			}

			if (WIFEXITED(status))
				last_exit_val = WEXITSTATUS(status);
			else
				last_exit_val = 127;
		}
		else
			return cpid;
	}

	/* Avoid fd leaks, close unnecessary fds. Slightly overkill. */
	int fd_ix;
	for (fd_ix = 3; fd_ix < MAX_FDS; fd_ix++) 
		(void) close(fd_ix);

	/* Clear any zombies before/after every line. */
	kill_zombies();			

	return 0;
}

/* Kill any zombie process that hasn't been waited on yet. */
void kill_zombies (void) {
	int status = 0;
	while( waitpid(-1, &status, WNOHANG) > 0) { /* omg hai!! */  }
}

int process_pipelines (char *expline, int *cinfd, int *coutfd, int *cerrfd) {
	int cmd_ix = 0;				/* Point to beginning of command substring */
	int fd[2];					/* Gonna hold a pipe 
								 * fd[0] = read  (kinda like STDIN) 
								 * fd[1] = write (kinda like STDOUT) */
	int r_ix = 0;				/* Index seeking for pipes */
	int temp_fd = 0;			/* Store half a pipe */

	kill_zombies();
	
	r_ix = find_pipe(expline); 

	if (find_pipe(expline)) {
		expline[r_ix] = 0;			/* Set to 0 to capture substring */
		pipe(fd);
		processline(&expline[cmd_ix], *cinfd, fd[1], *cerrfd, \
					NO_WAIT_THX | NO_EXPAND_THX);
		close(fd[1]);					/* Close write end, not needed */
		expline[r_ix] = ' ';			/* Change pipe to blank to indicate it's
										 * been processed. */
		cmd_ix = r_ix + 1;				/* Next command starts after pipe */
		while (expline[r_ix] != 0) {
			temp_fd = fd[0];
			pipe(fd);
			r_ix = r_ix + find_pipe(&expline[r_ix]);	// breaks here when hit EOL
			expline[r_ix] = 0;
			processline(&expline[cmd_ix], temp_fd, fd[1], *cerrfd, \
						NO_WAIT_THX | NO_EXPAND_THX);
			close(fd[1]);
			close(temp_fd);

			expline[r_ix] = ' ';
			cmd_ix = r_ix + 1; 

			/* If there's no more pipes left, break out of loop and process 
			 * the final command. */
			if (!find_pipe(&expline[cmd_ix])) 
				break;
		}


		temp_fd = fd[0];
		/* Final pipe needs to wait */
		processline(&expline[cmd_ix], temp_fd, fd[1], *cerrfd, \
					WAIT_PLS | NO_EXPAND_THX);
		close(temp_fd);
	}

	return 0;
}


int process_redirect (char *expline, int *cinfd, int *coutfd, int *cerrfd) {
	char full_path[LINELEN]; 	/* Full path of file */
	char path[LINELEN];			/* Substring relative path of file */
	int len = strlen(expline);	/* Total length of current line */
	int in_quote = 0;			/* Avoid false positives of redirect chars */
	int nested_level = 0;		/* How deep I've gone into $() substrings */
	/* All files created here will have mode: rwx------, aka 0700 */
	mode_t mode = S_IRWXU;

	/* Scan for redirection operators. Avoid picking up on anything in quotes,
     * or nested in $() expansion calls. */
	int ix;
	for (ix = 0; ix < len; ix++) {
		path[0] = 0;
		full_path[0] = 0;
		/* Detect entering quote or nested child process commands */
		if (expline[ix] == '\"')
			in_quote = !in_quote;
		else if (expline[ix] == '(') {
			if (expline[ix-1] == '$')
				nested_level++;
		}
		else if (expline[ix] == ')')
			nested_level--;

		/* Redirect operators in quotes or in a nested statement are ignored */
		if (!in_quote && (nested_level == 0)) {
			/* Open input file */
			if (expline[ix] == '<') {
				expline[ix] = ' ';
				ix++;
				if (find_path(expline, &ix, path, full_path) < 0) {
					dprintf(*cerrfd, \
							"./msh: No file name for redirection operator\n");
					return -1;
				}
				else 
					*cinfd = open(full_path, O_RDONLY, mode);
			}
			/* Redirect standard output, append if existing */
			else if (expline[ix] == '>' && expline[ix+1] == '>') {
				expline[ix] = ' ';
				ix++;
				expline[ix] = ' ';
				ix++;
				if (find_path(expline, &ix, path, full_path) < 0) {
					dprintf(*cerrfd, \
							"./msh: No file name for redirection operator\n");
					return -1;
				}
				/* Create file, open write only, append to prev contents */
				int oflags = O_CREAT | O_WRONLY | O_APPEND;
				if ((*coutfd = open(full_path, oflags, mode)) < 0) {
					dprintf(*cerrfd, \
							"./msh: %s: No such file or directory\n", path);
					return -1;
				}
			}
			/* Redirect standard output, overwrite if existing */
			else if (expline[ix] == '>') {
				expline[ix] = ' ';
				ix++;
				if (find_path(expline, &ix, path, full_path) < 0) {
					dprintf(*cerrfd, \
							"./msh: No file name for redirection operator\n");
					return -1;
				}
				/* Create file, open write only and truncate prev contents */
				int oflags = O_CREAT | O_WRONLY | O_TRUNC;
				if ((*coutfd = open(full_path, oflags, mode)) < 0) {
					dprintf(*cerrfd, \
							"./msh: %s: No such file or directory\n", path);
					return -1;
				}
			}
			/* Redirect error output, append if existing */
			else if (expline[ix] == '2' && \
					 expline[ix+1] == '>' && \
					 expline[ix+2] == '>') {
				expline[ix] = ' ';
				ix++;
				expline[ix] = ' ';
				ix++;
				expline[ix] = ' ';
				ix++;
				if (find_path(expline, &ix, path, full_path) < 0) {
					dprintf(*cerrfd, \
							"./msh: No file name for redirection operator\n");
					return -1;
				}
				/* Create file, open write only, append to prev contents */
				int oflags = O_CREAT | O_WRONLY | O_APPEND;	
				if ((*cerrfd = open(full_path, oflags, mode)) < 0) {
					dprintf(*cerrfd, \
							"./msh: %s: No such file or directory\n", path);
					return -1;
				}
			}
			/* Redirect error output, truncate if existing */
			else if (expline[ix] == '2' && expline[ix+1] == '>') {
				expline[ix] = ' ';
				ix++;
				expline[ix] = ' ';
				ix++;
				if (find_path(expline, &ix, path, full_path) < 0) {
					dprintf(*cerrfd, \
							"./msh: No file name for redirection operator\n");
					return -1;
				}
				/* Create file, open write only, append to prev contents */
				int oflags = O_CREAT | O_WRONLY | O_TRUNC;	
				if ((*cerrfd = open(full_path, oflags, mode)) < 0) {
					dprintf(*cerrfd, \
							"./msh: %s: No such file or directory\n", path);
					return -1;
				}
			}

			/* open(2) doesn't reliably set permissions if file exists */
			fchmod(*cinfd, S_IRUSR | S_IWUSR);
			fchmod(*coutfd, S_IRUSR | S_IWUSR);
			fchmod(*cerrfd, S_IRUSR | S_IWUSR);
		}
	}
	return 0;
}

void catch_signal (int sig) {
	sigint_occurred = 1;
}

/* Seek to end of current substring, extract full path from relative path */
int find_path (char *expline, int *ix, char *path, char *full_path) {
	int start_ix = *ix;

	/* Seek past any leading spaces before path */
	while (isspace(expline[*ix]))
		(*ix)++;

	/* If the first char after spaces is EOL then no path was specified,
	 * return error value. Otherwise assign beginning of path pointer.  */
	if (expline[*ix] == 0)
		return -1;

	start_ix = *ix;

	while ((expline[*ix] != 0) && (!isspace(expline[*ix])))
		(*ix)++;

	char temp = expline[*ix];
	expline[*ix] = 0;
	strcat(path, &expline[start_ix]);
	(void) realpath(path, full_path);	
	expline[*ix] = temp;

	/* Overwrite all the redirect-related chars with spaces */
	while (start_ix < *ix) {
		expline[start_ix] = ' ';
		start_ix++;
	}

	return 0;			/* Sentinel found without error */ 
}

/* Seek to next | char found in the string.
   Return values:
   -	>1 	location of next pipe found
   -	 0  EOL found before next pipe */
int find_pipe (char *expline_nugget) {
	int pipe_ix = 0;

	while (expline_nugget[pipe_ix] != '|' && expline_nugget[pipe_ix] != 0) 
		pipe_ix++;

	if (expline_nugget[pipe_ix] == '|')
		return pipe_ix;
	else
		return 0;
}